{
  "hash": "450a815c3d5b960f52bb7df86b57aab3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Quarto\"\nformat: html\n---\n\n## 引言\n\nQuarto 是一个面向数据科学的统一创作框架，支持可完全复现的文档生成，且输出格式多样。\n\nQuarto 是一个命令行工具，而非 R 包，因此无法通过 `?` 获取帮助。不过可查阅[Quarto 官方文档](https://quarto.org/)。\n\n简言之，Quarto 就是进阶版的 R Markdown，它整合了 R Markdown 生态中的多个包（如 `rmarkdown`、`bookdown`、`distill`、`xaringan` 等），且扩展了对多语言（如 Python、Julia 和 R）的原生支持。\n\n使用 Quarto 需要安装命令行接口（CLI），但在 RStudio 中无须手动安装或加载，系统会在需要时自动完成相关配置。\n\n## Quarto 基础\n\nQuarto 文件包含三种重要的内容类型：\n\n1.  可选的 YAML 头部信息，使用 `---` 包围；\n2.  R 代码块，用三重反引号（\\`\\`\\`）包围；\n3.  普通文本，格式与markdown基本一致，比如 `#` 表示标题，`_文本_` 表示斜体。\n\n下图展示 RStudio 中的 `.qmd` 文档，可以点击代码块顶部的Run按钮（形似播放键）来运行每个代码块，或按快捷键 **Ctrl + Shift + Enter**。RStudio 会执行代码并将结果嵌入代码块下方显示。\n\n![](https://r4ds.hadley.nz/quarto/diamond-sizes-notebook.png)\n\n如果不希望在文档中直接看到图表和输出，而想使用 RStudio 的 Console 和 Plots 面板，可以点击Render旁的齿轮图标，切换为“Chunk Output in Console”模式，如下图所示。\n\n![](https://r4ds.hadley.nz/quarto/diamond-sizes-console-output.png)\n\n要生成包含所有文本、代码和结果的完整报告，可点击Render按钮，或使用快捷键 **Ctrl + Shift + K**。也可以通过代码方式执行，使报告在 Viewer 面板中显示，同时生成一个 HTML 文件：\n\n``` r\nquarto::quarto_render(\"diamond-sizes.qmd\")\n```\n\n在渲染过程中，Quarto 首先将 `.qmd` 文件交给 [knitr](https://yihui.org/knitr/)，它会执行所有代码块，并生成包含代码及其输出的 Markdown 文件。随后该 Markdown 文件会由 [pandoc](https://pandoc.org/) 处理，生成最终格式的文件（如 PDF、Word、HTML）。这个流程如下图所示。\n\n![](https://r4ds.hadley.nz/images/quarto-flow.png)\n\n通过以下路径即可创建 `.qmd` 文件： **File \\> New File \\> Quarto Document…**\n\nRStudio 会启动一个向导，帮助我们预先填充一些常用内容，并提示如何使用 Quarto 的核心功能。\n\n## 可视化编辑器\n\n在底层，Quarto 文档（.qmd 文件）中的正文使用 Markdown 编写。\n\n在可视化编辑器中，除了使用菜单栏按钮插入图像、表格、引用等，也可使用通用快捷键 ⌘ + /（Mac）或 Ctrl + /（Windows/Linux）插入。如果位于某行开头，只输入 `/` 也可以触发快捷方式。\n\n![](https://r4ds.hadley.nz/quarto/quarto-visual-editor.png)\n\n虽然可视化编辑器会以格式化方式展示内容，但底层仍以纯 Markdown 存储。可视化编辑器与源代码编辑器之间能够随时切换，从而方便查看和编辑内容。\n\n## 源代码编辑器\n\n使用源代码编辑器编辑 Quarto 文档需要掌握markdown语法，下面简单展示部分格式。\n\n``` text\n## Text formatting\n\n*italic* **bold** ~~strikeout~~ `code`\n\nsuperscript^2^ subscript~2~\n\n[underline]{.underline} [small caps]{.smallcaps}\n\n## Headings\n\n# 1st Level Header\n\n## 2nd Level Header\n\n### 3rd Level Header\n\n## Lists\n\n-   Bulleted list item 1\n\n-   Item 2\n\n    -   Item 2a\n\n    -   Item 2b\n\n1.  Numbered list item 1\n\n2.  Item 2.\n    The numbers are incremented automatically in the output.\n\n## Links and images\n\n<http://example.com>\n\n[linked phrase](http://example.com)\n\n![optional caption text](quarto.png){fig-alt=\"Quarto logo and the word quarto spelled in small case letters\"}\n\n## Tables\n\n| First Header | Second Header |\n|--------------|---------------|\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |\n```\n\n## 代码块\n\n在 Quarto 文档中插入一个代码块可以通过以下三种方式完成：\n\n-   使用快捷键：**Cmd + Option + I（Mac） / Ctrl + Alt + I（Windows/Linux）**\n-   点击编辑器工具栏中的 “Insert” 按钮图标\n-   手动输入代码块分隔符，比如```{r}\n\n代码块本身还有一个新快捷键：**Cmd/Ctrl + Shift + Enter**，可一次运行整个代码块。\n\n以下小节介绍代码块的头部结构：以 ```{r} 开始，后续添加代码块标签和多个块选项，每项单独占一行，前缀为 #|。\n\n------------------------------------------------------------------------\n\n### 块标签\n\n代码块可以指定一个可选的标签，例如：\n\n```{{r}}\n#| label: simple-addition\n1 + 1\n```\n\n输出：\n\n```         \n#> [1] 2\n```\n\n标签有三个好处：\n\n1.  能通过 RStudio 编辑器左下角的代码导航器快速跳转至特定块。\n2.  便于后续引用。\n3.  可构建缓存依赖关系。\n\n标签应简短且具描述性，不能含空格，建议使用连字符 `-` 分隔单词（不推荐使用下划线 `_`）。\n\n有一个特殊标签`setup`。当处于笔记本模式时，名为 `setup` 的代码块将在其它代码运行前被自动执行。\n\n此外，块标签必须唯一，不可重复。\n\n------------------------------------------------------------------------\n\n### 块选项\n\n可通过在代码块开头指定选项，对代码块输出进行控制。knitr 提供了近 60 个选项，可参考完整列表：https://yihui.org/knitr/options。\n\n以下是最常用的一些选项：\n\n-   `eval: false` —— 不运行代码。适用于展示示例代码，或临时屏蔽一大段代码而不逐行注释。\n-   `include: false` —— 运行代码，但**不显示代码和结果**。适合用于初始化设置代码。\n-   `echo: false` —— 不显示代码，但保留结果。适用于隐藏底层 R 代码。\n-   `message: false` / `warning: false` —— 不显示消息或警告信息。\n-   `results: hide` —— 隐藏文本输出；\n-   `fig-show: hide` —— 隐藏图形输出。\n-   `error: true` —— 即使代码报错也继续渲染。\n\n这些选项以 `#|` 前缀写在代码块头部，例如：\n\n```{{r}}\n#| label: simple-multiplication\n#| eval: false\n2 * 2\n```\n\n------------------------------------------------------------------------\n\n### 全局选项\n\n随着 knitr 使用的深入，可能默认的块选项不再符合需求，那么就需要在文档层面进行全局设置。在 YAML 区域中通过 `execute:` 字段设置默认块选项。\n\n例如，想要不显示代码，只展示结果，可以设置：\n\n```         \ntitle: \"My report\"\nexecute:\n  echo: false\n```\n\n由于 Quarto 是多语言设计，并非所有 knitr 选项都可放在 `execute` 下（部分选项仅适用于 knitr，不适用于其他执行引擎如 Jupyter）。但可以使用 `knitr`和`opts_chunk` 设置 knitr 专属的全局选项。\n\n例如要将注释符设置为 `#>`，并将代码与输出紧密排列，可设置：\n\n```         \ntitle: \"Tutorial\"\nknitr:\n  opts_chunk:\n    comment: \"#>\"\n    collapse: true\n```\n\n------------------------------------------------------------------------\n\n### 内联代码\n\n除了代码块，还可使用内联语法将 R 代码嵌入 Quarto 文本中。\n\n\n\n\n## 图形\n\nQuarto 文档中的图形可以直接嵌入，也可以由代码块生成。\n\n要从外部文件嵌入图像，可以在 RStudio 的可视化编辑器中使用 “Insert” 菜单并选择 **Figure / Image**。\n\nQuarto 中主要有五个选项用于调节图形尺寸：\n\n-   `fig-width`\n-   `fig-height`\n-   `fig-asp`\n-   `out-width`\n-   `out-height`\n\n图像尺寸调整比较复杂，因为图像有两个尺寸：R 生成图形的实际大小，以及输出文档中显示的大小。\n\n下面通过各种需求来介绍选项。\n\n图形保持一致的宽度会更美观，故而可以在默认设置中设定：\n\n```         \nfig-width: 6    # 图形宽度 6 英寸  \nfig-asp: 0.618  # 黄金比例  \n```\n\n用 `out-width` 控制图形的输出宽度，建议设为输出文档正文宽度的一个百分比，比如：\n\n```         \nout-width: \"70%\"\nfig-align: center\n```\n\n如果要在一行中放多个图形，可以使用 `layout-ncol` 设置为 2（两图并排）、3（三图并排）等等。这相当于自动为每张图设置了 `out-width` 为 50%、33% 等。\n\n如果图中文字太小，则调整 `fig-width`，且通常需要通过试错来确定最佳宽高比。\n\n若要在文字中穿插代码和图形，你可以使用 `fig-show: hold`，从而能让图形在代码之后展示。\n\n要为图添加标题，可以使用 `fig-cap`。添加标题后，图像会变成“浮动图形”（可编号、可引用）。\n\n## 表格\n\n生成表格同样有两种方式。一种是直接通过 “Insert Table” 菜单插入的 Markdown 表格；另一种是由代码块生成表格。\n\n默认情况下，Quarto 会以类似控制台输出的形式打印数据框和矩阵：\n\n``` r\nmtcars[1:5, ]\n#>                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n```\n\n如果希望数据的展示方式更有条理，可以使用 `knitr::kable()` 函数。例如此代码会生成下面的表格：\n\n``` r\nknitr::kable(mtcars[1:5, ])\n```\n\n| mpg               | cyl  | disp | hp  | drat | wt   | qsec  | vs    | am  | gear | carb |     |\n|-------------------|------|------|-----|------|------|-------|-------|-----|------|------|-----|\n| Mazda RX4         | 21.0 | 6    | 160 | 110  | 3.90 | 2.620 | 16.46 | 0   | 1    | 4    | 4   |\n| Mazda RX4 Wag     | 21.0 | 6    | 160 | 110  | 3.90 | 2.875 | 17.02 | 0   | 1    | 4    | 4   |\n| Datsun 710        | 22.8 | 4    | 108 | 93   | 3.85 | 2.320 | 18.61 | 1   | 1    | 4    | 1   |\n| Hornet 4 Drive    | 21.4 | 6    | 258 | 110  | 3.08 | 3.215 | 19.44 | 1   | 0    | 3    | 1   |\n| Hornet Sportabout | 18.7 | 8    | 360 | 175  | 3.15 | 3.440 | 17.02 | 0   | 0    | 3    | 2   |\n\n## 缓存\n\n一般来说，每次渲染文档时都会从一个完全干净的环境重新开始。这从可重复性的角度出发固然很好，能确保所有重要的计算都写已进代码。然而，如果一些计算耗时特别长，再次渲染会很痛苦。\n\n解决方案是设置 `cache: true`，从文档层次（也就是全局）缓存所有计算的结果：\n\n``` r\n---\ntitle: \"My Document\"\nexecute: \n  cache: true\n---\n```\n\n也可以在代码块级别启用缓存，仅缓存某个特定代码块中的计算结果：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 一段耗时计算的代码\n```\n:::\n\n\n不过，默认情况下缓存只基于代码自身，不包含依赖项。例如以下代码中，`processed_data` 代码块依赖于 `raw-data` 代码块：\n\n```{{r}}\n#| label: raw-data\n#| cache: true\nrawdata <- readr::read_csv(\"a_very_large_file.csv\")\n\n```{{r}}\n#| label: processed_data\n#| cache: true\nprocessed_data <- rawdata |> \n  filter(!is.na(import_var)) |> \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\n\n此时若缓存作为附属的 `processed_data` ，则意味着如果 `raw-data` 的调用发生变化，它并不会重新运行。可以使用 `dependson` 选项来避免这个问题，该选项应包含一个字符向量，列出该缓存块依赖的所有代码块。knitr 检测到被依赖代码发生变化时，会更新缓存块的结果。\n\n```{{r}}\n#| label: processed-data\n#| cache: true\n#| dependson: \"raw-data\"\nprocessed_data <- rawdata |> \n  filter(!is.na(import_var)) |> \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\n若要让缓存随着外部文件的变化而更新，可以使用 `cache.extra` 。该选项接受任意 R 表达式，只要其结果变化，缓存就会**失效**。\n\n另外还有一个实用函数`file.mtime()`，它会返回文件的最后修改时间。例如：\n\n```{{{r}}}\n#| label: raw-data\n#| cache: true\n#| cache.extra: !expr file.mtime(\"a_very_large_file.csv\")\nrawdata <- readr::read_csv(\"a_very_large_file.csv\")\n```\n建议**定期清理所有缓存**，使用：\n\n```\nknitr::clean_cache()\n```\n\n## 修bug\n\nQuarto 文档并非交互式环境，调试过程可能不太直观。但究其错误根源，主要分为文档结构问题与内嵌代码问题两类。\n\n一个典型的结构性错误是代码块标签重复，极易发生在复制粘贴时。解决方法：检查报错信息或文档源码，找到重复的标签名，手动将其修改为全局唯一的名称，例如将重复的 unnamed-chunk-1 分别改为 data-loading 和 plot-generation。\n\n当错误由 R 代码本身引起时，核心的排查思路是在交互式环境中复现问题。方法：首先重启 R 会话，创造一个干净的环境，然后运行 Ctrl + Alt + R 执行文档中的所有代码块。一旦成功复现，就可以像处理普通 R 脚本一样，使用 print()、browser() 或调试器进行逐行交互式诊断。\n\n如果无法在交互环境中复现，则证明两者环境存在差异，必须进行系统排查。系统性解决方法：首先，通过包含 getwd() 的代码块确认 Quarto 的工作目录，并在交互会话中通过 setwd() 切换到相同路径。其次，在问题代码块顶部设置 error: true，确保渲染不会因报错而中断；然后，在代码块内部关键步骤后，插入 str()、print() 或 ls() 等语句，将变量内容、数据结构乃至当前环境中的所有对象名称打印输出，通过对比两份输出结果，即可发现隐藏的变量差异或依赖缺失。\n\n## YAML\n\nQuarto 使用 YAML 调整输出的细节。\n\n------------------------------------------------------------------------\n\n### 自包含\n\nHTML 文档通常依赖诸多外部资源（例如图片、CSS 样式表、JavaScript 等），默认情况下这些文件会被放在与 `.qmd` 文件同目录下的 `_files` 文件夹中，并非自包含。\n\n若要将报告通过电子邮件发送出去，便常常需要**自包含**的 HTML 文件，其中嵌入所有依赖文件。可以如下设置：\n\n``` r\nformat:\n  html:\n    embed-resources: true\n```\n\n生成的文件是自包含的，在浏览器中显示时不需要任何外部文件或网络连接。\n\n------------------------------------------------------------------------\n\n## 参数\n\nQuarto 文档中可以包含一个或多个动态参数，格式为：\n\n```         \n\n```\n\n在YAML中使用 `params` 字段对参数进行指定。例如，下面这个例子使用参数 `my_class` 来决定要展示哪一类汽车：\n\n```        \n---\nformat: html\nparams:\n  my_class: \"suv\"\n---\n```\n\n另外也可以通过 `!expr` 来动态执行任意 R 表达式。例如用于设置日期/时间参数：\n\n```         \nparams:\n  start: !expr lubridate::ymd(\"2015-01-01\")\n  snapshot: !expr lubridate::ymd_hms(\"2015-01-01 12:30:00\")\n```\n\n------------------------------------------------------------------------\n\n## 参考文献与引用\n\n要使用可视化编辑器添加引用，选择**Insert \\> Citation**。可以从多种来源插入引用：\n\n-   DOI（文献数字对象唯一标识符）\n-   Zotero 个人或团队图书馆\n-   Crossref、DataCite 或 PubMed 的搜索结果\n-   本地 `.bib` 文献数据库文件\n\n在源码编辑器中，使用引用标识符进行引用。其格式为 `'@' + 文献条目ID`，再放到方括号中。例如：\n\n```         \n多个引用用分号分隔\nBlah blah [@smith04; @doe99].\n\n可以在方括号内添加任意注释\nBlah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].\n\n去掉方括号以创建正文引用\n@smith04 says blah, or @smith04 [p. 33] says blah.\n\n在引用前加 `-` 省略作者名\nSmith says blah [-@smith04].\n```\n\n在渲染文档时，Quarto 会构建参考文献并附加到文档末尾，但不会自动添加章节标题，因此要手动添加。\n\n## 工作流程\n\nQuarto 的一大优势是紧密整合了**代码与文本**，既可开发代码，又能记录思路。\n\nQuarto的记录应追求三大目标：\n\n1.  **追溯完整过程**。系统性地记录每个操作步骤及其背后的决策逻辑，能够确保重要信息不会遗失。\n2.  **显性思考**。实时记录分析思路和反思过程，形成严谨的分析逻辑链。从而提升最终报告的质量，减少后期文档整理的工作量。\n3.  **团队协作**。数据分析本质上是协作性工作，记录信息利于团队知识传递及后续工作延续。\n\n作者对于工作记录的方法论如下：\n\n-   给记录文件取一个有描述性且易懂的文件名，且开头一段应当简要说明分析目的。\n\n-   使用 YAML 头部的 `date` 字段记录你开始工作的日期时，使用 **ISO8601 格式（YYYY-MM-DD）**，避免歧义：\n\n    ```         \n    date: 2016-08-23\n    ```\n\n-   如果在某个分析思路上投入了大量时间，但最终发现是死胡同，也不要删除！以后重新回顾这个分析时，它可以作为前车之鉴。\n\n-   最好在 R 之外进行数据录入。若不得不记录少量数据，应使用 `tibble::tribble()` 明确列出。\n\n-   如果发现数据文件中有错误，绝不直接修改原始文件， 而应该写代码去修正该值，并添加注释。\n\n-   结束每天的工作前，执行完整渲染验证文档可运行性，同时记得清除缓存。\n\n-   如果希望代码在未来依然可复现（比如一年后能再次运行），就需要追踪代码使用的**包的版本**。可使用 [renv](https://rstudio.github.io/renv/index.html) 将包保存在项目目录中。也可以代码块中运行 `sessionInfo()`，便能知道当前使用了哪些包。\n\n-   建议将自己的每个笔记本放在独立的项目中，并制定标准化命名方案。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}